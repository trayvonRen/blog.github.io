## 对称密钥加密  
对称密钥算法（英语：Symmetric-key algorithm）又称为**对称加密**、**私钥加密**、**共享密钥加密**是密码学中的一类加密算法。  
这类算法在加密和解密时使用相同的密钥，或是使用两个可以简单地相互推算的密钥。   
只要密钥不泄露，那么加密内容就是安全的。      

这种加密算法优点是加密和解密都很快，但是有个致命的缺点  
**收发者双发都必须提前获取密匙，并且需要保证密匙不泄露，否则传递内容很可能被第三者破解。**   
在互联网中，安全的传递密匙，几乎是不可能。因为基于 TCP/IP 的传输协议，传输的内容在整个互联网都是可见的。  
为了解决这个问题，人们又提出了非对称加密。
##  非对称加密  
公开密钥密码学（英语：Public-key cryptography）也称非对称式密码学（英语：Asymmetric cryptography）是密码学的一种算法，它需要两个密钥，一个是公开密钥，另一个是私有密钥。    
先有私钥，再用函数生成公钥。公钥包含了私钥的信息，但也掺杂了其他随机变量，因此不能反推。  
用公钥加密的内容必须用私钥才能解开，同样，私钥加密的内容只有公钥能解开。 

加密和解密的过程：  
- 服务器先生成私钥，然后得到公钥
- 服务器把公钥直接明文传输给浏览器  
- 浏览器把内容用公钥加密，传输给服务器
:::warning 注意点
- 公钥是公开的，人人都可以得到
- 私钥是保密的。只要私钥不泄露，传递的内容就无法被破解  
:::

#### 存在的问题   
浏览器到服务器这段路看似是安全了，但是服务器到浏览器的这条路怎么保障安全？ 如果服务器用它的的私钥加密数据传给浏览器，那么浏览器用公钥可以解密它，而这个公钥是一开始通过明文传输给浏览器的，这个公钥被谁劫持到的话，他也能用该公钥解密服务器传来的信息了。所以目前似乎只能保证由浏览器向服务器传输数据时的安全性。  
为了解决这个问题，可以使用两套公钥和密钥进行双向加密。这个就可以保证传输的安全性。但是非对称加密算法非常耗时，特别是加密解密一些较大数据的时候有些力不从心。
为了解决这个问题，`HTTPS` 采用了非对称加密 + 对称加密。

## 混合加密  
既然非对称加密耗时，非对称加密+对称加密结合可以吗？而且得尽量减少非对称加密的次数。当然是可以的，而且非对称加密、解密各只需用一次即可。  

请看一下这个过程：
- 某网站拥有用于非对称加密的公钥A、私钥A’。
- 浏览器像网站服务器请求，服务器把公钥A明文给传输浏览器。
- 浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器。
- 服务器拿到后用私钥A’解密得到密钥X。
- 这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都用密钥X加密解密。

完美！`HTTPS` 基本就是采用了这种方案。 
#### 中间人攻击  
但是这就一定安全了吗？  
假如有个中间人，想要攻击该网站。中间人的确无法得到浏览器生成的密钥B，这个密钥本身被公钥A加密了，只有服务器才有私钥A’解开拿到它呀！然而中间人却完全不需要拿到密钥A’就能干坏事了。请看：  
- 某网站拥有用于非对称加密的公钥A、私钥A’。
- 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。
- 中间人劫持到公钥A，保存下来，把数据包中的公钥A替换成自己伪造的公钥B（它当然也拥有公钥B对应的私钥B’）。
- 浏览器随机生成一个用于对称加密的密钥X，用公钥B（浏览器不知道公钥被替换了）加密后传给服务器。
- 中间人劫持后用私钥B’解密得到密钥X，再用公钥A加密后传给服务器。
- 服务器拿到后用私钥A’解密得到密钥X。  

这样在双方都不会发现异常的情况下，中间人得到了密钥B。  
**根本原因是浏览器无法确认自己收到的公钥是不是网站自己的**。  
为了解决这个问题，`HTTPS` 在混合加密的基础上使用了数字签名 + 数字证书的方式来验证身份。


## 数字证书 & 数字签名  
#### 数字证书
网站在使用 `HTTPS` 前，需要向 `CA机构` 申请颁发一份数字证书，数字证书里有证书持有者、证书持有者的公钥等信息，服务器把证书传输给浏览器，浏览器从证书里取公钥就行了，证书就如身份证一样，可以证明“该公钥对应该网站”。  
然而这里又有一个显而易见的问题了，证书本身的传输过程中，如何防止被篡改？即如何证明证书本身的真实性？身份证有一些防伪技术，数字证书怎么防伪呢？解决这个问题我们就基本接近胜利了！   
`HTTPS` 使用数字签名来验证证书的真伪。

#### 数字签名
我们把证书内容生成一份“签名”，比对证书内容和签名是否一致就能察觉是否被篡改。这种技术就叫数字签名  
<img src="/img/security/sign.jpg" width="400">
#### 数字签名的制作过程：
- `CA` 拥有非对称加密的私钥和公钥。
- `CA` 对证书明文信息进行 hash。
- 对 hash 后的值用私钥加密，得到数字签名。  

明文和数字签名共同组成了数字证书，这样一份数字证书就可以颁发给网站了。
那浏览器拿到服务器传来的数字证书后，如何验证它是不是真的？（有没有被篡改、掉包）  

#### 浏览器验证过程：
- 拿到证书，得到明文 `T`，数字签名 `S`。
- 用 `CA` 机构的公钥对 `S` 解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到 `S’`。
- 用证书里说明的 hash 算法对明文 `T` 进行 hash 得到 `T’`。
- 比较 `S’` 是否等于 `T’`，等于则表明证书可信。

#### 中间人有可能篡改该证书吗？ 
假设中间人篡改了证书的原文，由于他没有 `CA` 机构的私钥，所以无法得到此时加密后签名，无法相应地篡改签名。浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人。
#### 中间人有可能把证书掉包吗？  
假设有另一个网站 `B` 也拿到了 `CA` 机构认证的证书，它想搞垮网站 `A`，想劫持网站 `A` 的信息。于是它成为中间人拦截到了 `A` 传给浏览器的证书，然后替换成自己的证书，传给浏览器，之后浏览器就会错误地拿到 `B` 的证书里的公钥了，会导致上文提到的漏洞。
其实这并不会发生，因为证书里包含了网站 `A` 的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。  
#### 怎么证明CA机构的公钥是可信的？
你们可能会发现上文中说到 `CA` 机构的公钥，我几乎一笔带过，“浏览器保有它的公钥”，这是个什么保有法？怎么证明这个公钥是否可信？
让我们回想一下数字证书到底是干啥的？没错，为了证明某公钥是可信的，即“该公钥是否对应该网站/机构等”，那这个 `CA` 机构的公钥是不是也可以用数字证书来证明？没错，操作系统、浏览器本身会预装一些它们信任的根证书，如果其中有该CA机构的根证书，那就可以拿到它对应的可信公钥了。
实际上证书之间的认证也可以不止一层，可以A信任B，B信任C，以此类推，我们把它叫做信任链或数字证书链，也就是一连串的数字证书，由根证书为起点，透过层层信任，使终端实体证书的持有者可以获得转授的信任，以证明身份。 
另外，不知你们是否遇到过网站访问不了、提示要安装证书的情况？这里安装的就是跟证书。说明浏览器不认给这个网站颁发证书的机构，那么没有该机构的根证书，你就得手动下载安装（风险自己承担XD）。安装该机构的根证书后，你就有了它的公钥，就可以用它验证服务器发来的证书是否可信了。  

#### HTTPS 一定安全吗？
- `HTTPS` 可以确保加密内容不被中间人破解或者篡改，但是如果访问的网站本身就是冒牌网站，还是会有很大风险。   
- `HTTP` 进行身份验证的核心就是 `CA` 机构的数字证书，如果 `CA` 机构出现问题，整个 `HTTPS` 的安全性就崩溃了。  
- 如果攻击者入侵了电脑，修改了浏览器存储的证书信息，那么 `HTTPS` 也就无效了。（我觉得，如果电脑被入侵了，不管什么协议都救不了了。）
- 如果攻击者窃取了服务器的密钥，非对称加密也会失效，那么 `HTTPS` 也就无效了。  

## 总结  
- 对称加密算法的原理比较简单，所以加密解密快。
- 非对称加密算法核心是实现：公钥加密只有私钥能解开。因为算法的复杂性，所以加密解密时间比较长。
- 数字证书由 `CA` 颁发的，用于验证网站身份。
- 数字签名用于验证证书真伪。
- 数字签名 + 数字证书可以确保加密内容不被中间人破解或者篡改  


## 参考资料
[维基百科：对称密钥加密](https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%A8%B1%E5%AF%86%E9%91%B0%E5%8A%A0%E5%AF%86)  
[维基百科：公开密钥加密](https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86)  
[知乎：彻底搞懂HTTPS的加密机制](https://zhuanlan.zhihu.com/p/43789231)  
**关于非对称加密算法的数学原理**    
[阮一峰: RSA算法原理（一）](https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)  
[阮一峰: RSA算法原理（二）](https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)  