## TCP 报文格式

<img src="/img/network/tcp.png">
TCP报文段的首部分为固定部分和选项部分，固定部分长20byte，而选项部分长度可变。（若整个首部长度不是4byte的整数倍的话，则需要用填充位来填充）

在固定首部中，与本文密切相关的是以下几项：

- seq（序号）：TCP 连接字节流中每一个字节都会有一个编号，而本字段的值指的是本报文段所发送数据部分第一个字节的序号。

- ack（确认号）：表示期望收到的下一个报文段数据部分的第一个字节的编号，编号为 ack-1 及以前的字节已经收到。
- SYN：当本字段为 1 时，表示这是一个连接请求或者连接接受报文。
- ACK：仅当本字段为 1 时，确认号才有效。
- FIN：用来释放一个连接。当本字段为 1 时，表示此报文段的发送端数据已发送完毕，要求释放运输连接。

## TCP 建立连接

连接建立阶段：

- 第一次握手：客户端的应用进程主动打开，并向服务端发出请求报文段。其首部中：SYN=1,seq=x。
- 第二次握手：服务器应用进程被动打开。若同意客户端的请求，则发回确认报文，其首部中：SYN=1,ACK=1,ack=x+1,seq=y。
- 第三次握手：客户端收到确认报文之后，通知上层应用进程连接已建立，并向服务器发出确认报文，其首部：ACK=1,ack=y+1。当服务器收到客户端的确认报文之后，也通知其上层应用进程连接已建立。

在这个过程中，通信双方的状态如下图，其中 CLOSED：关闭状态、LISTEN：收听状态、SYN-SENT：同步已发送、SYN-RCVD：同步收到、ESTAB-LISHED：连接已建立

<img src="/img/network/connect.jpg">

至此，TCP 连接就建立了，客户端和服务器可以愉快地玩耍了。只要通信双方没有一方发出连接释放的请求，连接就将一直保持。

:::warning
第三次握手的目的是“为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误”，这种情况是：一端(client)A 发出去的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到连接释放以后的某个时间才到达另一端(server)B。本来这是一个早已失效的报文段，但是 B 收到此失效的报文之后，会误认为是 A 再次发出的一个新的连接请求，于是 B 端就向 A 又发出确认报文，表示同意建立连接。如果不采用“三次握手”，那么只要 B 端发出确认报文就会认为新的连接已经建立了，但是 A 端并没有发出建立连接的请求，因此不会去向 B 端发送数据，B 端没有收到数据就会一直等待，这样 B 端就会白白浪费掉很多资源。如果采用“三次握手”的话就不会出现这种情况，B 端收到一个过时失效的报文段之后，向 A 端发出确认，此时 A 并没有要求建立连接，所以就不会向 B 端发送确认，这个时候 B 端也能够知道连接没有建立
:::

## TCP 释放连接

连接释放阶段：

- 第一次握手：数据传输结束以后，客户端的应用进程发出连接释放报文段，并停止发送数据，其首部：FIN=1,seq=u。-
- 第二次握手：服务器端收到连接释放报文段之后，发出确认报文，其首部：ack=u+1,seq=v。此时本次连接就进入了半关闭状态，客户端不再向服务器发送数据。而服务器端仍会继续发送。
- 第三次握手：若服务器已经没有要向客户端发送的数据，其应用进程就通知服务器释放 TCP 连接。这个阶段服务器所发出的最后一个报文的首部应为：FIN=1,ACK=1,seq=w,ack=u+1。
- 第四次握手：客户端收到连接释放报文段之后，必须发出确认：ACK=1,seq=u+1,ack=w+1。 再经过 2MSL(最长报文端寿命)后，本次 TCP 连接真正结束，通信双方完成了他们的告别。

在这个过程中，通信双方的状态如下图，其中：ESTAB-LISHED：连接建立状态、FIN-WAIT-1：终止等待 1 状态、FIN-WAIT-2：终止等待 2 状态、CLOSE-WAIT：关闭等待状态、LAST-ACK：最后确认状态、TIME-WAIT：时间等待状态、CLOSED：关闭状态

<img src="/img/network/release.jpg">

:::warning
在结束连接的过程中，为什么在收到服务器端的连接释放报文段之后，客户端还要继续等待 2MSL 之后才真正关闭 TCP 连接呢？  
这里有两个原因：第一个是：需要保证服务器端收到了客户端的最后一条确认报文。假如这条报文丢失，服务器没有接收到确认报文，就会对连接释放报文进行超时重传，而此时客户端连接已关闭，无法做出响应，就造成了服务器端不停重传连接释放报文，而无法正常进入关闭状态的状况。而等待 2MSL，就可以保证服务器端收到了最终确认；若服务器端没有收到，那么在 2MSL 之内客户端一定会收到服务器端的重传报文，此时客户端就会重传确认报文，并重置计时器。
第二个是：存在一种“已失效的连接请求报文段”，需要避免这种报文端出现在本连接中，造成异常。
这种“已失效的连接请求报文段”是这么形成的：假如客户端发出了连接请求报文，然而服务器端没有收到，于是客户端进行超时重传，再一次发送了连接请求报文，并成功建立连接。然而，第一次发送的连接请求报文并没有丢失，只是在某个网络结点中发生了长时间滞留，随后，这个最初发送的报文段到达服务器端，会使得服务器端误以为客户端发出了新的请求，造成异常。
:::
